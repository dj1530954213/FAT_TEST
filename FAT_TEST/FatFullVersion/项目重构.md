# 项目重构：DataEditViewModel 与 ChannelMapping 状态管理

## I. 引言

本文档旨在为 `FatFullVersion` 项目中 `DataEditViewModel.cs` 的重构提供指导。当前 `DataEditViewModel` 类承担了过多的职责，特别是直接管理和修改 `ChannelMapping` 领域模型的大量状态属性，导致代码复杂、难以维护和测试。

**重构目标**：遵循"方案一"，将 `ChannelMapping` 的状态管理职责从 `DataEditViewModel` 中剥离出来，引入一个新的领域服务 `ChannelStateManager`（或类似名称，如 `ChannelOperationService`）。该服务将集中处理 `ChannelMapping` 对象的所有状态转换、业务规则计算以及复杂操作。

**核心模型**：`ChannelMapping` 对象及其众多状态属性是本次重构的核心关注点。

## II. `ChannelMapping` 核心状态属性概览

以下是 `ChannelMapping` 对象中与状态管理密切相关的关键属性：

*   **标识与上下文信息**:
    *   `Id`: Guid (唯一标识)
    *   `TestTag`: string (测试标签，包含创建时间等)
    *   `TestId`: string (来自Excel的序列号)
    *   `ChannelTag`: string (通道标签，如 "机架1_槽2_AI_点1")
    *   `VariableName`: string (变量名)
    *   `ModuleType`: string (模块类型: "AI", "AO", "DI", "DO", "AINone", etc.)
    *   `ModuleName`: string (模块名)
    *   `StationName`: string (站名)
    *   `VariableDescription`: string (变量描述)
    *   `DataType`: string (数据类型)
    *   `WireSystem`, `PowerSupplyType`: string (线制和有源/无源)
*   **通信与范围**:
    *   `PlcCommunicationAddress`: string (被测PLC通讯地址)
    *   `TestPLCCommunicationAddress`: string (测试PLC通讯地址)
    *   `RangeLowerLimitValue`, `RangeUpperLimitValue`: float (量程上下限)
*   **核心测试状态**:
    *   `HardPointTestResult`: string (硬点测试结果: "未测试", "等待测试", "测试中", "通过", "失败: [原因]", "跳过")
    *   `TestResultStatus`: int (整体测试结果: `0`=未测试, `1`=通过, `2`=失败)
    *   `ResultText`: string (综合的、用户可见的测试结果文本描述)
    *   `Status`: string (可能是 `ResultText` 的简化版或早期版本，建议统一或废弃)
*   **时间戳**:
    *   `StartTime`: DateTime? (测试开始时间)
    *   `TestTime`: DateTime? (一般测试时间，可能是硬点测试开始时间)
    *   `FinalTestTime`: DateTime? (通道最终测试完成时间)
*   **手动测试子状态 (根据 `ModuleType` 相关性不同)**:
    *   `ShowValueStatus`: string (显示值核对: "未测试", "通过", "失败")
    *   **AI 特有**:
        *   `SLLSetValue`, `SLSetValue`, `SHSetValue`, `SHHSetValue`: string (报警原始设定值)
        *   `SLLSetPointCommAddress`, `SLSetPointCommAddress`, `SHSetPointCommAddress`, `SHHSetPointCommAddress`: string (报警设定值通讯地址)
        *   `LowLowAlarmStatus`, `LowAlarmStatus`, `HighAlarmStatus`, `HighHighAlarmStatus`: string (各报警测试状态: "未测试", "通过", "失败")
        *   `AlarmValueSetStatus`: string (报警值设定核对状态: "未测试", "通过", "失败")
        *   `MaintenanceFunction`: string (维护功能测试状态: "未测试", "通过", "失败", "N/A")
        *   `MaintenanceEnableSwitchPointCommAddress`: string (维护使能开关通讯地址)
        *   `TrendCheck`, `ReportCheck`: string (趋势/报表检查状态: "未测试", "通过", "失败", "N/A")
    *   **AO 特有**:
        *   `TrendCheck`, `ReportCheck`: string (趋势/报表检查状态: "未测试", "通过", "失败", "N/A")
        *   ValueXPercent (e.g., `Value0Percent`, `Value25Percent`): double (用于记录测试中的实际值，非直接状态)
    *   **DI/DO 特有**:
        *   (多种AI/AO子状态对它们为 "N/A")
*   **分配与批次信息**:
    *   `TestBatch`: string (所属测试批次名称)
    *   `TestPLCChannelTag`: string (映射的测试PLC通道标签)

## III. `ChannelMapping` 状态变更核心流程与场景

以下流程描述了 `ChannelMapping` 对象状态在各个业务场景中如何发生变化。`ChannelStateManager` 将封装这些状态设定逻辑。

### 1. 初始化与数据导入 (原 `ProcessImportedDataAsync`)
*   **流程**: 从Excel文件读取点表数据 -> 为每条数据创建 `ChannelMapping` 实例。
*   **`ChannelMapping` 状态设定**:
    *   赋予基本属性 (如 `VariableName`, `ModuleType`, `PlcCommunicationAddress` 等)。
    *   `TestResultStatus = 0` (未测试)。
    *   `ResultText = "未测试"`。
    *   `HardPointTestResult = "未测试"`。
    *   根据 `ModuleType` 初始化子状态：
        *   **AI**:
            *   若点表中无低/低低报警设定 (`SLLSetValue`, `SLSetValue` 为空)，则 `LowLowAlarmStatus = "通过"`, `LowAlarmStatus = "通过"`。
            *   若点表中无高/高高报警设定 (`SHSetValue`, `SHHSetValue` 为空)，则 `HighHighAlarmStatus = "通过"`, `HighAlarmStatus = "通过"`。
            *   若所有报警均无设定，则 `AlarmValueSetStatus = "通过"`。
            *   其他AI子状态 (`ShowValueStatus`, `MaintenanceFunction`, `TrendCheck`, `ReportCheck`) 初始化为 "未测试"。
        *   **AO**:
            *   `LowLowAlarmStatus`, `LowAlarmStatus`, `HighAlarmStatus`, `HighHighAlarmStatus` 设为 "N/A"。
            *   `MaintenanceFunction` 设为 "通过" (此处存疑，AO的维护功能逻辑需确认，点表导入时即为通过)。
            *   `ShowValueStatus`, `TrendCheck`, `ReportCheck` 初始化为 "未测试"。
        *   **DI/DO**:
            *   量程相关、百分比值、报警状态、维护功能、趋势、报表均设为 "N/A" 或 `double.NaN`。
            *   `ShowValueStatus` 初始化为 "未测试"。
    *   其他属性如 `WireSystem`, `PowerSupplyType`, `RangeLowerLimitValue`, `RangeUpperLimitValue` 根据导入数据设置。

### 2. 通道分配与清除
*   **2.1. 执行通道分配 (原 `ExecuteAllocateChannels`)**
    *   **流程**: 调用 `_channelMappingService.AllocateChannelsTestAsync`，该服务返回分配好测试批次和测试PLC信息的 `ChannelMapping` 集合。
    *   **`ChannelMapping` 状态设定**: (由 `_channelMappingService` 或后续同步逻辑完成)
        *   `TestBatch` (e.g., "批次1")。
        *   `TestPLCChannelTag`。
        *   `TestPLCCommunicationAddress`。
*   **2.2. 清除通道分配 (原 `ClearChannelAllocationsAsync`)**
    *   **流程**: 调用 `_channelMappingService.ClearAllChannelAllocationsAsync`。
    *   **`ChannelMapping` 状态设定**:
        *   `TestBatch = string.Empty`。
        *   `TestPLCChannelTag = string.Empty`。
        *   `TestPLCCommunicationAddress = string.Empty`。

### 3. 批次选择与接线确认
*   **3.1. 批次选择 (原 `ConfirmBatchSelection`, `OnBatchSelected`)**
    *   **流程**: 用户在UI上选择一个已分配的 `TestBatch`。
    *   **`ChannelMapping` 状态影响**: 此操作主要影响 `DataEditViewModel` 中 `CurrentChannels` 的内容，通常不直接改变 `ChannelMapping` 实例的状态，而是筛选显示。
*   **3.2. 确认接线完成 (原 `ExecuteConfirmWiringComplete`)**
    *   **流程**: 用户确认所选批次的物理接线已完成。
    *   **`ChannelMapping` 状态设定** (针对当前 `SelectedBatch` 内的通道):
        *   若 `HardPointTestResult` 为 "未测试" 或空, 更新为 `HardPointTestResult = "等待测试"`。
        *   若 `ResultText` 为 "未测试" 或空, 更新为 `ResultText = "等待测试"`。

### 4. 模块跳过 (原 `ConfirmSkipModule`)
*   **流程**: 用户选择一个或多个模块，并填写跳过原因后确认。
*   **`ChannelMapping` 状态设定** (针对所选模块包含的所有通道):
    *   `HardPointTestResult = "跳过"`。
    *   `TestResultStatus = 1` (跳过通常视为一种形式的"完成"或"通过"，不阻塞整体进度)。
    *   `ResultText = $"已跳过测试，原因: {SkipReason}"`。
    *   相关的具体子测试状态 (如 `ShowValueStatus`, 报警状态等) 应更新为 "跳过" 或 "N/A"，以反映其未被执行。
    *   `FinalTestTime = DateTime.Now` (因为此通道的测试流程已结束)。

### 5. 硬点自动测试
*   **5.1. 测试启动 (原 `StartTest`)**
    *   **流程**: 用户点击"通道硬点自动测试"按钮 -> 调用 `_testTaskManager.StartAllTasksAsync()`。
    *   **`ChannelMapping` 状态设定** (针对当前 `SelectedBatch` 内需要进行硬点测试的通道):
        *   `StartTime = DateTime.Now`, `TestTime = DateTime.Now` (或仅更新 `TestTime`)。
        *   `FinalTestTime = null` (清除旧值，因为测试刚开始)。
        *   若 `HardPointTestResult` 为 "未测试" 或 "等待测试", 更新为 `HardPointTestResult = "测试中"`。
        *   `ResultText` 更新，例如：如果原为 "等待测试"，则变为 "硬点通道测试中"；如果已有其他手动测试信息，则附加 ", 硬点通道测试中"。
*   **5.2. 测试结果处理 (主要通过事件 `OnTestResultsUpdated`)**
    *   **流程**: `_testTaskManager` 或其子任务完成对某个硬点的测试 -> 发布包含测试结果的事件 -> `DataEditViewModel` 的 `OnTestResultsUpdated` 方法被调用。
    *   **`ChannelMapping` 状态设定** (针对事件中指定的通道，基于传入的 `HardPointTestResult` 原始值):
        *   `HardPointTestResult` 更新为事件传递的实际结果 (e.g., "通过", "失败: 具体通讯错误", etc.)。
        *   **如果 `HardPointTestResult` 为 "通过" 或 "已通过"**:
            *   `TestResultStatus` 更新为 `1` (通过)，但前提是 `TestResultStatus` 当前不为 `2` (即手动测试部分未曾导致失败)。
            *   `ResultText` 更新，例如从 "...硬点通道测试中" 变为 "...硬点通道测试成功"。
        *   **如果 `HardPointTestResult` 为 "失败" (或任何非通过的值)**:
            *   `TestResultStatus` 更新为 `2` (失败)。
            *   `ResultText` 更新，例如从 "...硬点通道测试中" 变为 "...硬点通道测试失败: {HardPointTestResult具体原因}"。
        *   若硬点测试完成（无论成功或失败），并且该通道没有后续手动测试步骤或手动测试也已完成，则 `FinalTestTime = DateTime.Now`。

### 6. 手动测试流程 (以 AI 通道为例，DI/DO/AO 流程类似，但具体子测试项不同)
*   **6.1. 打开手动测试窗口 (e.g., 原 `OpenAIManualTest`)**
    *   **流程**: 用户在UI上选中一个通道，点击对应的手动测试按钮。
    *   **`ChannelMapping` 状态设定** (针对当前选中的 `CurrentChannel`):
        *   如果各子测试项状态 (如 `ShowValueStatus`, `HighAlarmStatus` 等) 此前不是 "通过", 则将其重置/初始化为 "未测试"。
        *   如果通道尚有未完成的子测试项，`ResultText` 更新为 (或附加) "手动测试中"。
        *   `FinalTestTime = null` (因为手动测试刚开始或仍在进行)。
*   **6.2. 执行并确认手动子测试项 (e.g., 原 `ExecuteConfirmAIValue`, `ExecuteConfirmAIHighAlarm`, `ExecuteConfirmAIMaintenance` 等)**
    *   **流程**: 用户在手动测试窗口执行某项操作 (如模拟输入、检查PLC状态、确认界面显示)，然后点击对应的"确认XX"按钮。
    *   **`ChannelMapping` 状态设定** (针对 `CurrentChannel`):
        *   更新该子测试项的状态，例如 `channel.ShowValueStatus = "通过"` 或 `channel.HighAlarmStatus = "失败"`。
        *   **关键**: 调用一个统一的内部逻辑 (原 `CheckAllSubTestsCompleted` 的职责) 来评估当前通道的整体状态：
            *   **检查该模块类型所有必需的手动子测试项是否均已达到 "通过" 状态。**
            *   **如果所有相关手动子测试项均为 "通过"**:
                *   并且，如果其 `HardPointTestResult` 也为 "通过" (或 "跳过", 或对该通道类型不适用如 "N/A")：
                    *   `TestResultStatus = 1` (整体通过)。
                    *   `ResultText = "测试已通过"` (或更具体的成功描述)。
                    *   `Status = "通过"`。
                    *   `FinalTestTime = DateTime.Now`。
                *   如果其 `HardPointTestResult` 为 "失败":
                    *   `TestResultStatus = 2` (整体失败，即使手动部分通过，硬点失败决定最终结果)。
                    *   `ResultText` 应能反映此情况，例如 "硬点测试失败, 手动项已核对"。
                    *   `FinalTestTime = DateTime.Now`。
            *   **如果任何一个手动子测试项为 "失败"**:
                *   `TestResultStatus = 2` (整体失败)。
                *   `ResultText` 更新以指明失败的子测试环节，例如 "手动测试失败: 高报未触发"。
                *   `Status = "失败"`。
                *   `FinalTestTime = DateTime.Now` (因为测试因失败而结束)。
            *   **如果尚有手动子测试项为 "未测试" (即测试仍在进行中)**:
                *   `TestResultStatus` 通常保持不变或根据当前是否有失败项设为 `2`。
                *   `ResultText` 更新为 "手动测试中: [下一步或当前状态]"。
                *   `FinalTestTime` 保持 `null`。

### 7. 重新测试 (原 `Retest`)
*   **流程**: 用户选择一个之前测试失败或不满意的通道，点击"复测"按钮。
*   **`ChannelMapping` 状态设定**:
    *   首先，需要将该通道的状态重置到一个适合重新开始测试的状态。这可能包括：
        *   `TestResultStatus = 0` (未测试) 或根据复测类型回到特定阶段。
        *   `HardPointTestResult = "等待测试"` (如果复测包含硬点测试) 或保持/清除。
        *   清除相关的子测试状态 (如 `ShowValueStatus`, 报警状态等) 回到 "未测试"。
        *   `ResultText = "等待复测"` 或类似。
        *   `FinalTestTime = null`。
    *   然后，根据通道类型和失败点，重新触发相应的测试流程 (可能是硬点自动测试流程，或打开手动测试窗口提示用户操作)。
    *   后续的状态变更将遵循第 5 或第 6 部分的逻辑。
    *   (注意: `_testTaskManager.RetestChannelAsync` 的具体行为需要明确，它是否直接修改通道状态，还是通过事件机制反馈)。

### 8. 测试记录恢复 (原 `RestoreTestRecords`)
*   **流程**: 用户从历史记录中选择一个测试批次，确认恢复。
*   **`ChannelMapping` 状态设定**:
    *   当前工作区的所有 `ChannelMapping` 数据 (`AllChannels`, `OriginalAllChannels`) 被从数据库加载的对应历史批次的 `ChannelMapping` 记录完全替换。
    *   这意味着每个 `ChannelMapping` 实例的所有属性，包括所有上述的状态属性 (`TestResultStatus`, `ResultText`, `HardPointTestResult`, 各子测试状态, `FinalTestTime` 等)，都恢复到选定历史批次测试结束时的状态。

## IV. `ChannelStateManager` 服务接口初步设想

基于上述流程，`ChannelStateManager` 服务可能需要提供类似以下的方法 (具体方法名和参数可进一步细化):

*   `InitializeChannelFromImport(ChannelMapping channel, ExcelPointData pointData, DateTime importTime)`
*   `UpdateChannelAllocationInfo(ChannelMapping channel, string testBatch, string testPlcChannelTag, string testPlcCommAddress)`
*   `ClearChannelAllocationInfo(ChannelMapping channel)`
*   `MarkChannelAsSkipped(ChannelMapping channel, string reason)`
*   `PrepareChannelForWiringConfirmation(ChannelMapping channel)`
*   `PrepareChannelForHardPointTest(ChannelMapping channel)`
*   `UpdateChannelWithHardPointTestResult(ChannelMapping channel, string rawHardPointResult)`
*   `PrepareChannelForManualTest(ChannelMapping channel)`
*   `RecordManualSubTestOutcome(ChannelMapping channel, ManualTestType testType, bool isSuccess, string details = null)`
*   `ResetChannelStateForRetest(ChannelMapping channel)`
*   `RestoreChannelFromHistoricalData(ChannelMapping channel, HistoricalChannelData historicalData)` (或者服务直接返回新的/更新的实例)
*   `EvaluateAndSetOverallChannelStatus(ChannelMapping channel)` (关键方法，可能在多个操作后被内部调用，或由ViewModel在必要时调用)

## V. 后续步骤

1.  **定义 `IChannelStateManager` 接口**：明确服务契约。
2.  **实现 `ChannelStateManager` 类**：将 `DataEditViewModel` 中相关的状态修改逻辑逐步迁移到此类中。
3.  **重构 `DataEditViewModel`**：修改其方法以调用 `ChannelStateManager` 服务，而不是直接操作 `ChannelMapping` 属性。ViewModel 将负责流程编排和UI更新（基于从 `ChannelStateManager` 或 `ChannelMapping` 获取的状态）。
4.  **单元测试**：为 `ChannelStateManager` 编写单元测试，确保状态转换逻辑的正确性。

通过以上梳理，我们对 `ChannelMapping` 状态的复杂性和涉及的流程有了更清晰的认识，这将为接下来的重构工作打下坚实的基础。
